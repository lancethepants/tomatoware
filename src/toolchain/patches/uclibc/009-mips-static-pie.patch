diff -Naur uClibc-ng-1.0.42.orig/extra/Configs/Config.in uClibc-ng-1.0.42/extra/Configs/Config.in
--- uClibc-ng-1.0.42.orig/extra/Configs/Config.in	2022-08-24 14:43:52.053644468 -0600
+++ uClibc-ng-1.0.42/extra/Configs/Config.in	2022-08-24 14:44:01.205807929 -0600
@@ -324,7 +324,7 @@
 config STATIC_PIE
 	bool "Add support for Static Position Independent Executables (PIE)"
 	default n
-	depends on DOPIC && !UCLIBC_FORMAT_FDPIC_ELF && (TARGET_arm || TARGET_i386 || TARGET_x86_64 || TARGET_aarch64)
+	depends on DOPIC && !UCLIBC_FORMAT_FDPIC_ELF && (TARGET_arm || TARGET_i386 || TARGET_x86_64 || TARGET_aarch64 || TARGET_mips)
 
 config ARCH_HAS_NO_SHARED
 	bool
diff -Naur uClibc-ng-1.0.42.orig/ldso/ldso/mips/dl-startup.h uClibc-ng-1.0.42/ldso/ldso/mips/dl-startup.h
--- uClibc-ng-1.0.42.orig/ldso/ldso/mips/dl-startup.h	2022-08-24 14:43:52.057644539 -0600
+++ uClibc-ng-1.0.42/ldso/ldso/mips/dl-startup.h	2022-08-24 14:44:01.205807929 -0600
@@ -7,6 +7,7 @@
 
 
 #include <sgidefs.h>
+#ifndef L_rcrt1
 __asm__(""
     "	.text\n"
     "	.globl	_start\n"
@@ -114,6 +115,7 @@
     "\n\n"
     ".previous\n"
 );
+#endif
 
 /*
  * Get a pointer to the argv array.  On many platforms this can be just
@@ -191,6 +193,5 @@
 	case R_MIPS_NONE:							\
 		break;								\
 	default:								\
-		SEND_STDERR("Aiieeee!");					\
 		_dl_exit(1);							\
 	}
diff -Naur uClibc-ng-1.0.42.orig/libc/misc/internals/Makefile.in uClibc-ng-1.0.42/libc/misc/internals/Makefile.in
--- uClibc-ng-1.0.42.orig/libc/misc/internals/Makefile.in	2022-08-24 14:43:52.029644038 -0600
+++ uClibc-ng-1.0.42/libc/misc/internals/Makefile.in	2022-08-24 14:44:01.205807929 -0600
@@ -17,7 +17,7 @@
 MISC_INTERNALS_OBJ := $(patsubst %.c,$(MISC_INTERNALS_OUT)/%.o,$(CSRC-y))
 
 CFLAGS-__uClibc_main.c := $(SSP_DISABLE_FLAGS)
-CFLAGS-reloc_static_pie.c := $(SSP_DISABLE_FLAGS)
+CFLAGS-reloc_static_pie.c := $(SSP_DISABLE_FLAGS) -DL_rcrt1
 
 libc-y += $(MISC_INTERNALS_OBJ)
 ifneq ($(UCLIBC_FORMAT_SHARED_FLAT),y)
diff -Naur uClibc-ng-1.0.42.orig/libc/misc/internals/reloc_static_pie.c uClibc-ng-1.0.42/libc/misc/internals/reloc_static_pie.c
--- uClibc-ng-1.0.42.orig/libc/misc/internals/reloc_static_pie.c	2022-08-24 14:43:52.029644038 -0600
+++ uClibc-ng-1.0.42/libc/misc/internals/reloc_static_pie.c	2022-08-24 14:44:01.205807929 -0600
@@ -20,28 +20,91 @@
 #include <elf.h>
 #include <dl-elf.h>
 
+#include <ldso.h>
+#ifdef __mips__
+#include <dl-startup.h>
+#endif
+
 ElfW(Addr) _dl_load_base = NULL;
 
 void
 reloc_static_pie (ElfW(Addr) load_addr);
 
 void
-reloc_static_pie (ElfW(Addr) load_addr)
+reloc_static_pie(ElfW(Addr) load_addr)
 {
-    ElfW(Word) relative_count = 0;
-    ElfW(Addr) rel_addr = 0;
-    ElfW(Dyn) * dyn_addr = NULL;
-    unsigned long dynamic_info[DYNAMIC_SIZE] = {0};
-
-    /* Read our own dynamic section and fill in the info array.  */
-    dyn_addr = ((void *) load_addr + elf_machine_dynamic ());
-
-    /* Use the underlying function to avoid TLS access before initialization */
-    __dl_parse_dynamic_info(dyn_addr, dynamic_info, NULL, load_addr);
-
-    /* Perform relocations */
-    relative_count = dynamic_info[DT_RELCONT_IDX];
-    rel_addr = dynamic_info[DT_RELOC_TABLE_ADDR];
-    elf_machine_relative(load_addr, rel_addr, relative_count);
+    int indx;
+    ElfW(Addr) got;
+    ElfW(Dyn) *dpnt;
+    struct elf_resolve tpnt_tmp;
+	struct elf_resolve *tpnt = &tpnt_tmp;
+
+    DL_BOOT_COMPUTE_GOT(got);
+    DL_BOOT_COMPUTE_DYN(dpnt, got, (DL_LOADADDR_TYPE)load_addr);
+
+    _dl_memset(tpnt, 0, sizeof(struct elf_resolve));
+    tpnt->loadaddr = load_addr;
+    tpnt->dynamic_addr = dpnt;
+
+    __dl_parse_dynamic_info(dpnt, tpnt->dynamic_info, NULL, load_addr);
+
+#if defined(PERFORM_BOOTSTRAP_GOT)
+	/* some arches (like MIPS) we have to tweak the GOT before relocations */
+	PERFORM_BOOTSTRAP_GOT(tpnt);
+#endif
+
+
+#if defined(ELF_MACHINE_PLTREL_OVERLAP)
+# define INDX_MAX 1
+#else
+# define INDX_MAX 2
+#endif
+
+    for (indx = 0; indx < INDX_MAX; indx++) {
+        unsigned long rel_addr, rel_size;
+        ElfW(Word) relative_count = tpnt->dynamic_info[DT_RELCONT_IDX];
+
+        rel_addr = (indx ? tpnt->dynamic_info[DT_JMPREL] :
+                           tpnt->dynamic_info[DT_RELOC_TABLE_ADDR]);
+        rel_size = (indx ? tpnt->dynamic_info[DT_PLTRELSZ] :
+			               tpnt->dynamic_info[DT_RELOC_TABLE_SIZE]);
+
+        if (!rel_addr)
+            continue;
+
+        if((0 == indx) && relative_count) {
+			rel_size -= relative_count * sizeof(ELF_RELOC);
+            elf_machine_relative(load_addr, rel_addr, relative_count);
+			rel_addr += relative_count * sizeof(ELF_RELOC);
+        }
+
+#ifdef ARCH_NEEDS_BOOTSTRAP_RELOCS
+			{
+				ELF_RELOC *rpnt;
+				unsigned int i;
+				ElfW(Sym) *sym;
+				unsigned long symbol_addr;
+				int symtab_index;
+				unsigned long *reloc_addr;
+
+				/* Now parse the relocation information */
+				rpnt = (ELF_RELOC *) rel_addr;
+				for (i = 0; i < rel_size; i += sizeof(ELF_RELOC), rpnt++) {
+					reloc_addr = (unsigned long *) DL_RELOC_ADDR(load_addr, (unsigned long)rpnt->r_offset);
+					symtab_index = ELF_R_SYM(rpnt->r_info);
+					symbol_addr = 0;
+					sym = NULL;
+					if (symtab_index) {
+						ElfW(Sym) *symtab;
+						symtab = (ElfW(Sym) *) tpnt->dynamic_info[DT_SYMTAB];
+						sym = &symtab[symtab_index];
+						symbol_addr = (unsigned long) DL_RELOC_ADDR(load_addr, sym->st_value);
+					}
+					/* Use this machine-specific macro to perform the actual relocation.  */
+					PERFORM_BOOTSTRAP_RELOC(rpnt, reloc_addr, symbol_addr, load_addr, sym);
+				}
+			}
+#endif
+    }
     _dl_load_base = load_addr;
-}
+}
\ No newline at end of file
diff -Naur uClibc-ng-1.0.42.orig/libc/sysdeps/linux/mips/crt1.S uClibc-ng-1.0.42/libc/sysdeps/linux/mips/crt1.S
--- uClibc-ng-1.0.42.orig/libc/sysdeps/linux/mips/crt1.S	2022-08-24 14:43:52.045644324 -0600
+++ uClibc-ng-1.0.42/libc/sysdeps/linux/mips/crt1.S	2022-08-24 14:45:05.698891501 -0600
@@ -78,6 +78,11 @@
 	.weak	_init
 	.weak	_fini
 #endif
+#ifdef L_rcrt1
+	.type	reloc_static_pie,@function
+	.weak	reloc_static_pie
+	.hidden .L0
+#endif
 	.type	    main,@function
 	.type	    __uClibc_main,@function
 	.ent	__start
@@ -90,6 +95,24 @@
 	PTR_LA $28, _gp             /* Setup GP correctly if we're non-PIC.  */
 	move $31, $0
 #endif
+#ifdef L_rcrt1
+    PTR_LA $4, _DYNAMIC           /* Place _DYNAMIC into the GOT */
+    REG_S $4, -0x7ff0($28)
+	jal .L0                        /* Get the current $pc address */
+.L0:
+	INT_SUB $25, $31, $25         /* Calculate load addr */
+	move $4, $25                  /* store load addr in param 1 */
+	and $29, -2 * SZREG           /* Ensure stack is aligned */
+	addi $29, $29, (-2 * SZREG)   /* Allocate 2 register spaces on stack */
+	REG_S $2, SZREG($29)          /* Store atexit in case it exists */
+	PTR_LA $5, reloc_static_pie   /* function calls before relocation
+	                                 don't work unless we set $t9 manually */
+	INT_ADDU $25, $25, $5         /* store reloc_static_pie in $t9 */
+	bal reloc_static_pie          /* call, and pray the compiler adds a nop
+	                                 in delay slot */
+	REG_L $2, SZREG($29)          /* cleanup stack */
+	addi $29, $29, (2 * SZREG)
+#endif
 
 	PTR_LA $4, main		/* main */
 	PTR_L $5, 0($29)		/* argc */
